# This file generated by Quarto; do not edit by hand.
# shiny_mode: core

from __future__ import annotations

from pathlib import Path
from shiny import App, Inputs, Outputs, Session, ui

import pandas as pd
import ridgeplot as rp
import plotly.express as px
import pickle
from sklearn.manifold import TSNE
from sklearn.decomposition import SparsePCA
from sklearn.preprocessing import StandardScaler
import numpy as np
from shiny.express import input, render, ui
from shinywidgets import render_plotly
import numpyro
from tensorly.decomposition import tucker
import jax 
numpyro.set_host_device_count(100)

# ========================================================================

from data.data_utils import create_fda_data
data = pd.read_csv("data/player_data.csv").query(" age <= 38 ")
names = data.groupby("id")["name"].first().values
names_df = pd.DataFrame(names, columns = ["Name"])
names_df["Player"] = range(len(names))
metric_output = ["binomial", "poisson"] + (["gaussian"] * 2) + (["poisson"] * 9) + (["binomial"] * 3)
metrics = ["retirement", "minutes", "obpm","dbpm","blk","stl","ast","dreb","oreb","tov","fta","fg2a","fg3a","ftm","fg2m","fg3m"]
metric_df = pd.DataFrame(metrics, columns=["Statistic"])
metric_df["Metric"] = range(len(metrics))
basis = np.arange(18, 39)
age_df = pd.DataFrame(range(18,39), columns = ["Age"])
age_df["Time"] = age_df["Age"] - 18
exposure_list = (["simple_exposure"] * 2) + (["minutes"] * 11) + ["fta","fg2a","fg3a"]
data["retirement"] = 1
data["log_min"] = np.log(data["minutes"])
data["simple_exposure"] = 1 
_ , outputs, _ = create_fda_data(data, basis_dims=3, metric_output=metric_output, 
                                     metrics = metrics
, exposure_list =  exposure_list)
observations = np.stack([output["output_data"] for output in outputs], axis = 1)
exposures = np.stack([output["exposure_data"] for output in outputs], axis = 0)
agg_dict = {"obpm":"mean", "dbpm":"mean", "bpm":"mean", 
            "position_group": "max",
        "minutes":"sum", "dreb": "sum", "fta":"sum", "ftm":"sum", "oreb":"sum",
        "ast":"sum", "tov":"sum", "fg2m":"sum", "fg3m":"sum", "fg3a":"sum", "fg2a":"sum", "blk":"sum", "stl":"sum"}
data["total_minutes"] = data["median_minutes_per_game"] * data["games"] 
agged_data = data.groupby("id").agg(agg_dict).reset_index()
agged_data["ft_pct"] = agged_data["ftm"] / agged_data["fta"]
agged_data["fg2_pct"] = agged_data["fg2m"] / agged_data["fg2a"]
agged_data["fg3_pct"] = agged_data["fg3m"] / agged_data["fg3a"]
agged_data["dreb_rate"] = 36.0 * agged_data["dreb"] / agged_data["minutes"]
agged_data["oreb_rate"] = 36.0 * agged_data["oreb"] / agged_data["minutes"]
agged_data["ast_rate"] = 36.0 * agged_data["ast"] / agged_data["minutes"]
agged_data["tov_rate"] = 36.0 * agged_data["tov"] / agged_data["minutes"]
agged_data["blk_rate"] = 36.0 * agged_data["blk"] / agged_data["minutes"]
agged_data["stl_rate"] = 36.0 * agged_data["stl"] / agged_data["minutes"]
agged_data["ft_rate"] = 36.0 * agged_data["fta"] / agged_data["minutes"]
agged_data["fg2_rate"] = 36.0 * agged_data["fg2a"] / agged_data["minutes"]
agged_data["fg3_rate"] = 36.0 * agged_data["fg3a"] / agged_data["minutes"]
agged_data.fillna(0, inplace=True)

# ========================================================================

# N, K, T = observations.shape

# edges = []
# nodes = []
# vals = []
# missing = []
# for player_index in range(N):
#     for metric_index in range(K):
#         for time_index in range(T):
#             cur_node = (player_index, metric_index, time_index)
#             nodes.append(cur_node)
#             missing.append(np.isfinite(exposures[metric_index, player_index, time_index]))
#             vals.append(observations[player_index, metric_index, time_index])

#             if player_index != N - 1:
#                 edges.append((cur_node, (player_index + 1, metric_index ,time_index)))

#             if player_index != 0:
#                 edges.append((cur_node, (player_index - 1, metric_index, time_index )))
            
#             if metric_index != K - 1:
#                 edges.append((cur_node, (player_index, metric_index + 1, time_index)))

#             if metric_index != 0:
#                 edges.append((cur_node, (player_index, metric_index - 1, time_index)))

#             if time_index != T - 1:
#                 edges.append((cur_node, (player_index, metric_index, time_index + 1)))

#             if time_index != 0:
#                 edges.append((cur_node, (player_index, metric_index, time_index - 1)))

# nodes_df = pd.DataFrame(np.array([list(x) for x in zip(*nodes)]).T, columns=["Player", "Metric", "Time"])
# nodes_df["Value"] = vals
# nodes_df["Missing"] = missing

# final_data_plot_df = pd.merge(nodes_df, names_df).merge(metric_df).merge(age_df)

# ========================================================================

import jax.numpy as jnp
from jax import vmap
from model.hsgp import make_convex_f, diag_spectral_density, make_convex_phi, make_psi_gamma
with open("model_output/latent_variable.pkl", "rb") as f:
    results = pickle.load(f)
f.close()

X = results["X"]


with open("model_output/fixed_latent_convex_nba_tvrflvm_svi_poisson_minutes.pkl", "rb") as f:
    results_tvrflvm_svi = pickle.load(f)
f.close()

with open("model_output/fixed_latent_convex_nba_tvrflvm_mcmc_poisson_minutes.pkl", "rb") as f:
    results_tvrflvm = pickle.load(f)
f.close()

def make_mu(X, ls_deriv, alpha_time, shifted_x_time, weights, W, slope_weights, intercept_weights, L_time, M_time, phi_time):
    spd = jnp.sqrt(diag_spectral_density(1, alpha_time, ls_deriv, L_time, M_time))
    weights = weights * spd * .0001
    wTx = jnp.einsum("nr,mr -> nm", X, W)
    psi_x = jnp.hstack([jnp.cos(wTx), jnp.sin(wTx)]) * (1/ jnp.sqrt(50))
    slope = make_psi_gamma(psi_x, slope_weights)
    intercept = make_psi_gamma(psi_x, intercept_weights)
    gamma_phi_gamma_x = jnp.einsum("nm, mdk, tdz, jzk, nj -> nkt", psi_x, weights, phi_time, weights, psi_x)
    mu = make_convex_f(gamma_phi_gamma_x, x_time + L_time, slope, intercept)
    return mu

def make_mu_vmap(ls_samples, alpha_samples, beta_samples, W_samples, slope_samples, intercept_samples, x_time_shifted, L, M, phi, X):
    mu_vmap = vmap(vmap(lambda ls, alpha, beta, W, slope, intercept: make_mu(X, ls, alpha, x_time_shifted, beta, W, slope,
    intercept, L, M, phi)))
    return mu_vmap(ls_samples, alpha_samples, beta_samples, W_samples, slope_samples, intercept_samples)

hsgp_params = {}
x_time = basis - basis.mean()
L_time = 1.5 * jnp.max(jnp.abs(x_time), 0, keepdims=True)
M_time = 15
phi_time = make_convex_phi(x_time, L_time, M_time)
hsgp_params["phi_x_time"] = phi_time
hsgp_params["M_time"] = M_time
hsgp_params["L_time"] = L_time
hsgp_params["shifted_x_time"] = x_time + L_time

mu = make_mu(X, results_tvrflvm_svi["lengthscale_deriv__loc"], 
results_tvrflvm_svi["alpha__loc"], hsgp_params["shifted_x_time"],
results_tvrflvm_svi["beta__loc"], results_tvrflvm_svi["W__loc"], 
results_tvrflvm_svi["slope__loc"], results_tvrflvm_svi["intercept__loc"], 
L_time, M_time, phi_time)

# ========================================================================




def server(input: Inputs, output: Outputs, session: Session) -> None:
    U, _, _ = np.linalg.svd(X, full_matrices=False)
    L       = np.linalg.cholesky(np.cov(U.T) + 1e-6 * np.eye(7)).T
    aligned_X  = np.linalg.solve(L, U.T).T
    aligned_X /= np.std(X, axis=0)

    X_tsne = TSNE(n_components=3).fit_transform(aligned_X)


    scatter_df = pd.concat([pd.DataFrame(X_tsne, columns=[f"dim{i+1}" for i in range(3)]), agged_data], axis = 1)
    scatter_df["player_name"] = names

    # ========================================================================

    import jax.numpy as jnp
    import jax
    from scipy.special import expit
    def transform_mu(mu, metric_outputs):
        for index, output_type in enumerate(metric_outputs):
            if output_type == "gaussian":
                transform_function = lambda x: x 
            elif output_type == "poisson":
                transform_function = lambda x: np.exp(x)
            elif output_type == "binomial":
                transform_function = lambda x: expit(x)
            mu = mu.at[index].set(transform_function(mu[index]))
        return mu


    def make_mu_mcmc_max(X, ls_deriv, alpha_time, shifted_x_time, weights, W, slope_weights, intercept_weights, L_time, M_time, phi_time):
        spd = jax.vmap(jax.vmap(lambda a, ls: jnp.sqrt(diag_spectral_density(1, a, ls, L_time, M_time))))(alpha_time, ls_deriv)
        weights = weights * spd[:,:,None,...] * .0001

        wTx = jnp.einsum("nr,...mr -> ...nm", X, W)

        psi_x = jnp.concatenate([jnp.cos(wTx), jnp.sin(wTx)], -1) * (1/ jnp.sqrt(50))
        slope = jnp.einsum("ijnm, ijm... -> ijn...", psi_x, slope_weights)
        intercept = jnp.einsum("ijnm, ijm... -> ijn...",psi_x, intercept_weights)
        gamma_phi_gamma_x = jnp.einsum("...nm, ...mdk, tdz, ...jzk, ...nj -> ...nkt", psi_x, weights, phi_time, weights, psi_x)
        mu = jnp.swapaxes(intercept + jnp.einsum("...nk, t -> ...nkt", slope, shifted_x_time) - gamma_phi_gamma_x, 2,3)
        return None, jnp.argmax(jnp.squeeze(mu), -1) + 18

    _, peaks = jax.lax.scan(lambda _, xs: make_mu_mcmc_max(xs[None], results_tvrflvm["lengthscale_deriv"], results_tvrflvm["alpha"],
    hsgp_params["shifted_x_time"],
    results_tvrflvm["beta"], results_tvrflvm["W"], 
    results_tvrflvm["slope"], results_tvrflvm["intercept"], 
    L_time, M_time, phi_time
    ), init=None, xs = X
    )

    peaks = jnp.swapaxes(peaks, 0, -1)
    positions = ["G", "F", "C"]
    pos_indices = data.groupby("id")["position_group"].max().reset_index()
    position_samples_list = []
    for pos in positions:
        player_indices = pos_indices[pos_indices["position_group"] == pos].index.values
        player_samples = peaks[..., player_indices].mean(-1).reshape((len(metrics), -1))
        pos_samples_df = pd.DataFrame(player_samples.T, columns=metrics).melt(value_name="peak", var_name="metric")
        pos_samples_df["position"] = pos
        position_samples_list.append(pos_samples_df)

    position_samples_df = pd.concat(position_samples_list)

    samples_ridgeplot = [
        [
            position_samples_df[(position_samples_df["position"] == pos) & (position_samples_df["metric"] == metric)]["peak"]
            for pos in positions   
        ]
        for metric in metrics
    ]


    # mu_normalized = transform_mu((mu - mu.mean((1,2), keepdims = True)) / (mu.std((1,2), keepdims = True)), metric_output)
    # core, factors = tucker(mu_normalized, rank= [16, X.shape[0], 3])

    # full_core = jnp.einsum("jzm, kj, nz -> kzm", core, factors[0], factors[1])
    # pos_indices = data.groupby("id")["position_group"].max().reset_index()
    # positions = ["G", "F", "C"]
    # tensor_decomps = {}
    # tensor_decomps["global"] = {"core": core, "factors": factors, "full_core": full_core}
    # for pos in positions:
    #     player_indices = pos_indices[pos_indices["position_group"] == pos].index.values
    #     pos_mu = mu[:, player_indices ,:]
    #     pos_mu_normalized = transform_mu((pos_mu - pos_mu.mean((1,2), keepdims = True)) / (pos_mu.std((1,2), keepdims = True)), metric_output)
    #     core, factors = tucker(pos_mu_normalized,
    #                         rank = [16, X.shape[0], 3])
    #     full_pos_core = jnp.einsum("jzm, kj, nz -> kzm", core, factors[0], factors[1])
    #     tensor_decomps[pos] = {"core": core, "factors": factors, "full_core": full_pos_core}

    # ========================================================================

    ### combine with next slide maybe
    # from visualization.visualization import plot_career_trajectory_observations
    # ui.input_select(id="player_traj", label = "Select a player", choices = {index : name for index, name in enumerate(names)})
    # @render_plotly
    # def plot_metric_arc():
    #     return plot_career_trajectory_observations(int(input.player_traj()), metrics, metric_output, observations, exposures )

    # ========================================================================

    #### change time to actual age 
    # from visualization.visualization import plot_data_tensor
    # @render_plotly
    # def plot_data():
    #     return plot_data_tensor(final_data_plot_df)

    # ========================================================================

    # from visualization.visualization import plot_scatter
    # ui.input_select(id="player", label = "Select a player", choices = {index : name for index, name in enumerate(names)})

    # @render_plotly
    # def plot_latent_space():
    #     return plot_scatter(scatter_df,  "Latent Embedding", int(input.player()) )

    # ========================================================================

    # from visualization.visualization import plot_posterior_predictive_career_trajectory_map
    from visualization.visualization import plot_posterior_predictive_career_trajectory
    import jax.numpy as jnp

    # ui.input_select(id="player_posterior", label = "Select a player", choices = {index : name for index, name in enumerate(names)})

    # @render_plotly
    # def plot_posterior_predictive():
    #     player_index = int(input.player_posterior())
    #     mu_mcmc_player = jnp.squeeze(make_mu_vmap(results_tvrflvm["lengthscale_deriv"],
    #     results_tvrflvm["alpha"], results_tvrflvm["beta"], results_tvrflvm["W"], results_tvrflvm["slope"], results_tvrflvm["intercept"],
    #     hsgp_params["shifted_x_time"], L_time, M_time, phi_time, X[player_index][None]))
    #     return plot_posterior_predictive_career_trajectory(player_index=player_index,
    #     metrics=metrics,
    #     metric_outputs=metric_output, 
    #     posterior_mean_samples=mu_mcmc_player,
    #     observations=jnp.array(observations),
    #     exposure_names=exposure_list,
    #     exposures=jnp.array(exposures),
    #     posterior_variance_samples=jnp.transpose(results_tvrflvm["sigma"], (2, 0, 1)))

    # ========================================================================

    @render_plotly
    def post_dist_peak():
        fig = rp.ridgeplot(
        samples=samples_ridgeplot,
        labels=metrics,
        colorscale= ["orangered", "deepskyblue", "greens"],
        bandwidth=4)

        fig.update_layout(
        title="Distribution of Peak Performance by Position",
        height=650,
        width=950,
        font_size=14,
        plot_bgcolor="rgb(245, 245, 245)",
        xaxis_gridcolor="white",
        yaxis_gridcolor="white",
        xaxis_gridwidth=2,
        yaxis_title="Metric",
        xaxis_title="Peak Age",
        showlegend=False,
            )
        return fig

    # ========================================================================

    # with ui.layout_column_wrap():
    #     @render_plotly
    #     def plot_functional_bases_group():
    #         dfs = []
    #         for pos in positions:
    #             factors = tensor_decomps[pos]["factors"]
    #             funct_bases_df = pd.DataFrame(factors[2], columns = [f"Basis {i}" for i in range(1,4)])
    #             funct_bases_df["Position"] = pos
    #             funct_bases_df["Age"] = range(18,39)
    #             dfs.append(funct_bases_df)
    #         full_funct_bases = pd.concat(dfs)
    #         funct_bases_melted = pd.melt(full_funct_bases, id_vars = ["Position", "Age"], value_vars = [f"Basis {i}" for i in range(1,4)],
    #         var_name="basis_type", value_name="value")
    #         fig = px.line(funct_bases_melted, x = "Age", y = "value", color="Position", facet_col="basis_type")
    #         return fig
    
    #     @render_plotly
    #     def plot_metric_weights_bases_group():
    #         dfs = []
    #         for pos in positions:
    #             factors = tensor_decomps[pos]["factors"]
    #             weights = tensor_decomps[pos]["full_core"].mean(1).T
    #             weights_df = pd.DataFrame(weights, columns = metrics)
    #             weights_df["Position"] = pos
    #             weights_df["Basis"] = range(1,4)
    #             dfs.append(weights_df)
 
    #         weights_df = pd.concat(dfs)
    #         weights_df_melted = weights_df.melt(id_vars=["Basis", "Position"], var_name="Variable", value_name="Value")
    #         fig = px.bar(weights_df_melted, facet_row="Basis",x="Variable", y = "Value", facet_col="Position")
    #         return fig


    # ========================================================================

    # with ui.layout_column_wrap():
    #     ui.input_select(id="player_functional", label = "Select a player", choices = {index : name for index, name in enumerate(names)})
    # with ui.layout_column_wrap():
    #     @render_plotly
    #     def plot_functional_bases():
    #         player_index = int(input.player_functional())
    #         full_core = tensor_decomps["global"]["full_core"]
    #         factors = tensor_decomps["global"]["factors"]
    #         explained_var = full_core[:,player_index,:].T.var(1) / full_core[:,player_index,:].T.var(1).sum()
    #         funct_bases_df = pd.DataFrame(factors[2], columns = [f"Basis {i}: {explained_var[i-1]:.{3}}% EV" for i in range(1,4)])
    #         funct_bases_df["Age"] = range(18,39)
    #         funct_bases_melted = funct_bases_df.melt(id_vars="Age", var_name="Variable", value_name="Value")
    #         fig = px.line(funct_bases_melted, x = "Age", y = "Value", color="Variable")
    #         return fig
    #     @render_plotly
    #     def plot_metric_weights():
    #         player_index = int(input.player_functional())
    #         full_core = tensor_decomps["global"]["full_core"]
    #         factors = tensor_decomps["global"]["factors"]
    #         weights = full_core[:,player_index,:].T
    #         weights_df = pd.DataFrame(weights, columns = metrics)
    #         weights_df["Basis"] = range(1,4)
    #         weights_df_melted = weights_df.melt(id_vars="Basis", var_name="Variable", value_name="Value")
    #         fig = px.bar(weights_df_melted, facet_row="Basis",x="Variable", y = "Value")
    #         return fig

    # ========================================================================



    return None


_static_assets = ["advancement_files","images/noun-deep-learning-1705425.png","images/noun-scatter-graph-4768711.png","images/pgm_methods_flow.svg","images/cp_decomp.jpg","images/tuckerdecomp.png","images/pgm.svg","images/pmg_corr.svg"]
_static_assets = {"/" + sa: Path(__file__).parent / sa for sa in _static_assets}

app = App(
    Path(__file__).parent / "advancement.html",
    server,
    static_assets=_static_assets,
)
